---
output: html_document
---

#### Tratamento da primeira base sif utilizada (não é a atualmente utilizada 04/09/2025)

*Base atualmente utilizada inicia-se na linha 107*

```{r setup, include=FALSE, eval = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      error = FALSE,
                      collapse = TRUE,
                      comment = "#>")
source("../R/my-function.R")
```

### Faxina e Processamento de Dados de SIF (*solar induced fluorescence*) OCO-2/NASA.

1.  **Conversão de Unidades e Datas**

    -   Converte XCO₂ para ppm (`xco2_moles_mole_1*1e06`)
    -   Extrai ano/mês/dia do timestamp

2.  **Cálculo de SIF**\
    Combina medidas de fluorescência em 757nm e 771nm numa métrica única

3.  **Filtro Geográfico**

    -   Prepara polígonos das regiões brasileiras\
    -   Remove pontos oceânicos/distantes\
    -   Cria flags para Brasil (`flag_br`) e Nordeste (`flag_nordeste`)

4.  **Visualização Rápida**

    -   Mapa com amostra de 1.000 pontos sobre o território brasileiro

5.  **Classificação por Estado**

    -   Atribui cada ponto a um estado usando coordenadas

```{r, eval=FALSE}
dff <- fco2r::oco2_br |>
  dplyr::mutate(
    xco2 = xco2_moles_mole_1*1e06,
    date = lubridate::ymd_hms(time_yyyymmddhhmmss),
    year = lubridate::year(date),
    month = lubridate::month(date),
    day = lubridate::day(date),
    sif = (
      fluorescence_radiance_757nm_idp_ph_sec_1_m_2_sr_1_um_1*2.6250912*10^(-19)  + 1.5*fluorescence_radiance_771nm_idp_ph_sec_1_m_2_sr_1_um_1* 2.57743*10^(-19))/2)

regiao <- geobr::read_region(showProgress = FALSE)
pol_norte <- regiao$geom |> purrr::pluck(1) |> as.matrix()
pol_nordeste <- regiao$geom |> purrr::pluck(2) |> as.matrix()
pol_sudeste <- regiao$geom |> purrr::pluck(3) |> as.matrix()
pol_sul <- regiao$geom |> purrr::pluck(4) |> as.matrix()
pol_centroeste<- regiao$geom |> purrr::pluck(5) |> as.matrix()

# Retirando alguns pontos
pol_br <- pol_br[pol_br[,1]<=-34,]
pol_br <- pol_br[!((pol_br[,1]>=-38.8 & pol_br[,1]<=-38.6) &
                     (pol_br[,2]>= -19 & pol_br[,2]<= -16)),]

pol_nordeste <- pol_nordeste[pol_nordeste[,1]<=-34,]
pol_nordeste <- pol_nordeste[!((pol_nordeste[,1]>=-38.7 & pol_nordeste[,1]<=-38.6) & pol_nordeste[,2]<= -15),]

# Retirando alguns pontos
pol_br <- pol_br[pol_br[,1]<=-34,]
pol_br <- pol_br[!((pol_br[,1]>=-38.8 & pol_br[,1]<=-38.6) &
                     (pol_br[,2]>= -19 & pol_br[,2]<= -16)),]

pol_nordeste <- pol_nordeste[pol_nordeste[,1]<=-34,]
pol_nordeste <- pol_nordeste[!((pol_nordeste[,1]>=-38.7 & pol_nordeste[,1]<=-38.6) & pol_nordeste[,2]<= -15),]

# Recriando o flag_nordeste
dff <- dff |>
  dplyr::mutate(
    flag_br = def_pol(longitude, latitude, pol_br),
    flag_nordeste = def_pol(longitude, latitude, pol_nordeste)
  )

br |>
  ggplot2::ggplot() +
  ggplot2::geom_sf(fill="white", color="#FEBF57",
                   size=.15, show.legend = FALSE) +
  ggplot2::geom_point(data= dff |>
                        dplyr::sample_n(1000) |>
                        dplyr::filter(flag_br|flag_nordeste) ,
                      ggplot2::aes(x=longitude,y=latitude),
                      shape=3,
                      col="red",
                      alpha=0.2)

# Classificando pontos
data_set <- dff
state <- 0
x <- data_set |> dplyr::pull(longitude)
y <- data_set |> dplyr::pull(latitude)
for(i in 1:nrow(data_set)) state[i] <- get_geobr_state(x[i],y[i])
data_set <- data_set |> cbind(state)
dplyr::glimpse(data_set)
# readr::write_rds(data_set,"../data/oco2-sif.rds")
```

### Tratamento da segunda base sif utilizada (atualmente utilizada 04/09/2025)

**Variables and their meanings in table 1 of pdf "Global GOSAT, OCO-2, and OCO-3 solar-induced chlorophyll fluorescence datasets"** 

-***Chunk de classificação demorou cerca de 3 dias para finalizar***-

#### Classificando pontos dos estados com base nas coordenadas
```{r, eval=FALSE}
# original archive "oco-sif.rds" = 9.8mb
# original archive "oco-sif-complete.rds" = 4.5gb # Essa base não continha os dados classificados por estados

# oco2_sif <- read_rds("data/oco2-sif-complete.rds") 

# data_set <- oco2_sif
# state <- 0
# x <- data_set |> dplyr::pull(longitude)
# y <- data_set |> dplyr::pull(latitude)
# for(i in 1:nrow(data_set)) state[i] <- get_geobr_state(x[i],y[i])
# data_set <- data_set |> cbind(state)
# dplyr::glimpse(data_set)
# readr::write_rds(data_set,"data/oco2-sif-teste.rds")
```

**Agora, a base nomeada como "oco2-sif-teste.rds", contém os dados classificados por estado**

**Devemos classificá-los por município. Para isso:**

#### Entrada com a Base: `oco2-sif-classificado.rds` **(essa é aquela que te mandei no e-mail, nomeada como oco2-sif-teste)**
```{r, eval=FALSE} 
oco2_sif <- read_rds("../data/oco2-sif-classificado.rds")

glimpse(oco2_sif)
```


#### Filtrando base para facilitar tratamento

1. **O filtro consiste em:**
     - Remover coluna "state" duplicada
     - Filtrar para os estados do Brasil Central
     - Filtrar pelos dados com melhores observações
     
```{r, eval=FALSE}
my_states <- c("MS","MT","GO","DF") # estados Brasil Central

oco2_sif <- oco2_sif |> 
  select(-16) |> # remover coluna "state" duplicada
  filter(
    state == my_states,
    # state == Brasil,
    quality_flag == 0 | quality_flag == 1 # melhores observações 
  )

glimpse(oco2_sif)
```

#### Tratamento dos dados da sif
```{r, eval=FALSE}
# Carregando pacotes necessários
library(lubridate)
library(dplyr)

# Convertendo a coluna "time" para objeto de data-hora e extraindo colunas mes, data e dia para facilitar manipulações 
oco2_sif <- oco2_sif |> 
  mutate(
    time = as_datetime(time,
                       origin = '1990-01-01 00:00:00',
                       tz = "America/Sao_Paulo"),
    year = year(time),
    month = month(time),
    day = day(time)
  )

# tail(oco2_sif) #observar últimas linhas
```

#### Plotando pontos para determinado ano para verificar pontos
```{r, eval=FALSE}
# Lendo os estados do Brasil pelo geobr e extraindo apenas a coluna de siglas
Brasil <- read_state()$abbrev_state

oco2_sif |>
  filter(year == 2022,
         # state == my_states, # Brasil Central
         state == Brasil)|>
  ggplot(aes(x=longitude,y=latitude)) +
  geom_point()
```

#### Classificando cada ponto em município
```{r, eval=FALSE}

# Carregando pacotes
library(sf)
library(dplyr)
library(lwgeom) # para st_make_valid

# 1. Garantir que shapefile de municípios está no mesmo CRS (Coordinate Reference System) e seja válido
municipality_sf <- municipality %>% # Do script "my-function" --> municipality <- geobr::read_municipality(showProgress = FALSE)
  st_transform(crs = 4326) %>%
  st_make_valid()

# 2. Converter data frame para sf
oco2_sif_sf <- st_as_sf(
  oco2_sif,
  coords = c("longitude", "latitude"),
  crs = 4326,
  remove = FALSE # mantém as colunas originais lon/lat
)

# 3. Fazer o join espacial
# A função "st_join" faz uma junção entre dois objetos espaciais sf;
  # Essa junção é feita com base em relações espaciais (geometria);
    # Essa relação de geometria foi obtida do pacote geobr (municipality) e da base de dados da sif classificada por estado
oco2_sif_sf <- st_join(
  oco2_sif_sf,
  municipality_sf %>% select(name_muni),
  join = st_within
) 
# Observe que o número de linhas se manteve após o join (✅)


# 4. Criar coluna "city_ref", substituindo NA por "Other"
oco2_sif_sf <- oco2_sif_sf %>%
  mutate(city_ref = ifelse(is.na(name_muni), "Other", name_muni)) %>%
  select(-name_muni) # remove coluna original para não duplicar

# 5. Converter para data frame (para não manter como sf)
oco2_sif <- as.data.frame(oco2_sif_sf)

glimpse(oco2_sif) 

# Salvar arquivo 
# write_rds(oco2_sif, "../data/oco2-sif.rds")
```


